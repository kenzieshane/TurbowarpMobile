/** Values for the Record Type field, including Universal Hex custom types. */
declare enum RecordType {
    Data = 0,
    EndOfFile = 1,
    ExtendedSegmentAddress = 2,
    StartSegmentAddress = 3,
    ExtendedLinearAddress = 4,
    StartLinearAddress = 5,
    BlockStart = 10,
    BlockEnd = 11,
    PaddedData = 12,
    CustomData = 13,
    OtherData = 14
}
/**
 * Defines the fields for an Intel Hex record.
 *
 * @interface Record
 */
interface Record {
    byteCount: number;
    address: number;
    recordType: RecordType;
    data: Uint8Array;
    checksum: number;
}
declare const MAX_RECORD_STR_LEN: number;
/**
 * Creates an Intel Hex record with normal or custom record types.
 *
 * @param address - The two least significant bytes for the data address.
 * @param recordType - Record type, could be one of the standard types or any
 *    of the custom types created for forming a Universal Hex.
 * @param dataBytes - Byte array with the data to include in the record.
 * @returns A string with the Intel Hex record.
 */
declare function createRecord(address: number, recordType: RecordType, dataBytes: Uint8Array): string;
/**
 * Retrieves the Record Type form an Intel Hex record line.
 *
 * @param iHexRecord Intel hex record line without line terminator.
 * @returns The RecordType value.
 */
declare function getRecordType(iHexRecord: string): RecordType;
/**
 * Retrieves the data field from a record.
 *
 * @param iHexRecord Intel Hex record string.
 * @returns The record Data in a byte array.
 */
declare function getRecordData(iHexRecord: string): Uint8Array;
/**
 * Parses an Intel Hex record into an Record object with its respective fields.
 *
 * @param iHexRecord Intel hex record line without line terminator.
 * @returns New object with the Record interface.
 */
declare function parseRecord(iHexRecord: string): Record;
/**
 * Creates an End Of File Intel Hex record.
 *
 * @returns End of File record with new line.
 */
declare function endOfFileRecord(): string;
/**
 * Creates an Extended Linear Address record from a 4 byte address.
 *
 * @param address - Full 32 bit address.
 * @returns The Extended Linear Address Intel Hex record.
 */
declare function extLinAddressRecord(address: number): string;
/**
 * Creates a Block Start (custom) Intel Hex Record.
 *
 * @param boardId Board ID to embed into the record, 0 to 0xFFF.
 * @returns A Block Start (custom) Intel Hex record.
 */
declare function blockStartRecord(boardId: number): string;
/**
 * Create Block End (custom) Intel Hex Record.
 *
 * The Data field in this Record will be ignored and can be used for padding.
 *
 * @param padBytesLen Number of bytes to add to the Data field.
 * @returns A Block End (custom) Intel Hex record.
 */
declare function blockEndRecord(padBytesLen: number): string;
/**
 * Create a Padded Data (custom) Intel Hex Record.
 * This record is used to add padding data, to be ignored by DAPLink, to be able
 * to create blocks of 512-bytes.
 *
 * @param padBytesLen Number of bytes to add to the Data field.
 * @returns A Padded Data (custom) Intel Hex record.
 */
declare function paddedDataRecord(padBytesLen: number): string;
/**
 * Changes the record type of a Record to a Custom Data type.
 *
 * The data field is kept, but changing the record type will trigger the
 * checksum to be updated as well.
 *
 * @param iHexRecord Intel hex record line without line terminator.
 * @returns A Custom Data Intel Hex record with the same data field.
 */
declare function convertRecordTo(iHexRecord: string, recordType: RecordType): string;
/**
 * Converts and Extended Segment Linear Address record to an Extended Linear
 * Address record.
 *
 * @throws {Error} When the record does not contain exactly 2 bytes.
 * @throws {Error} When the Segmented Address is not a multiple of 0x1000.
 *
 * @param iHexRecord Intel hex record line without line terminator.
 */
declare function convertExtSegToLinAddressRecord(iHexRecord: string): string;
/**
 * Separates an Intel Hex file (string) into an array of Record strings.
 *
 * @param iHexStr Intel Hex file as a string.
 * @returns Array of Records in string format.
 */
declare function iHexToRecordStrs(iHexStr: string): string[];
/**
 * Iterates through the beginning of an array of Intel Hex records to find the
 * longest record data field length.
 *
 * Once it finds 12 records at the maximum size found so far (starts at 16
 * bytes) it will stop iterating.
 *
 * This is useful to identify the expected max size of the data records for an
 * Intel Hex, and then be able to generate new custom records of the same size.
 *
 * @param iHexRecords Array of Intel Hex Records.
 * @returns Number of data bytes in a full record.
 */
declare function findDataFieldLength(iHexRecords: string[]): number;
export { MAX_RECORD_STR_LEN, RecordType, createRecord, getRecordType, getRecordData, parseRecord, endOfFileRecord, extLinAddressRecord, blockStartRecord, blockEndRecord, paddedDataRecord, convertRecordTo, convertExtSegToLinAddressRecord, iHexToRecordStrs, findDataFieldLength, };
//# sourceMappingURL=ihex.d.ts.map